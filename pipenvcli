#!/usr/bin/env python
import os
import sys
import logging
import subprocess
from optparse import OptionParser, BadOptionError, AmbiguousOptionError


ROOT = os.path.dirname(os.path.realpath(__file__))
PIPENV_SANDBOX = os.path.join(ROOT, ".local", "pipenv")
PIPENV_BIN =  os.path.join(ROOT, "bin")
PIPENV_ENTRY = os.path.join(ROOT, "bin", "pipenv")
SET_ENV_SCRIPT = os.path.join(ROOT, "set_env.sh")


LOGGER = logging.getLogger(__name__)


class PassThroughOptionParser(OptionParser):
    """
    An unknown option pass-through implementation of OptionParser.

    When unknown arguments are encountered, bundle with largs and try again,
    until rargs is depleted.

    sys.exit(status) will still be called if a known argument is passed
    incorrectly (e.g. missing arguments or bad argument types, etc.)

    credit to justind: http://stackoverflow.com/questions/1885161/how-can-i-get-optparses-optionparser-to-ignore-invalid-options
    """
    def _process_args(self, largs, rargs, values):
        while rargs:
            try:
                OptionParser._process_args(self, largs, rargs, values)
            except (BadOptionError, AmbiguousOptionError) as e:
                largs.append(e.opt_str)

    def _process_short_opts(self, rargs, values):
        arg = rargs.pop(0)
        stop = False
        i = 1
        for ch in arg[1:]:
            opt = "-" + ch
            option = self._short_opt.get(opt)
            i += 1                      # we have consumed a character

            if not option:
                raise BadOptionError(arg)
            if option.takes_value():
                # Any characters left in arg?  Pretend they're the
                # next arg, and stop consuming characters of arg.
                if i < len(arg):
                    rargs.insert(0, arg[i:])
                    stop = True

                nargs = option.nargs
                if len(rargs) < nargs:
                    if nargs == 1:
                        self.error(_("%s option requires an argument") % opt)
                    else:
                        self.error(_("%s option requires %d arguments")
                                   % (opt, nargs))
                elif nargs == 1:
                    value = rargs.pop(0)
                else:
                    value = tuple(rargs[0:nargs])
                    del rargs[0:nargs]

            else:                       # option doesn't take a value
                value = None

            option.process(opt, value, values, self)

            if stop:
                break


parser = PassThroughOptionParser(add_help_option=False,)


def _pipenv_exists():
    if not os.path.exists(PIPENV_SANDBOX):
        return False
    if not os.path.isfile(PIPENV_ENTRY):
        return False
    return True


def _run_pipenv(args):
    if _pipenv_exists():
        # set env var properly
        os.environ["PATH"] = "{}:{}".format(PIPENV_BIN, os.environ.get("PATH"))
        command = [PIPENV_ENTRY]
        command.extend(args)
        subprocess.call(command)
    else:
        LOGGER.info("pipenv doesn't exist, please set up env first..")


def main(argv):
    options, args = parser.parse_args(argv)
    sys.exit(_run_pipenv(args))


def _create_stdout_logger():
    """ create a logger to stdout """
    log = logging.getLogger(__name__)
    out_hdlr = logging.StreamHandler(sys.stdout)
    out_hdlr.setFormatter(logging.Formatter('%(message)s'))
    out_hdlr.setLevel(logging.INFO)
    log.addHandler(out_hdlr)
    log.setLevel(logging.INFO)


if __name__ == "__main__":
    _create_stdout_logger()
    main(sys.argv[1:])
