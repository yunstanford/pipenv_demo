#!/usr/bin/env python
import os
import sys
import logging
import subprocess
from optparse import OptionParser, BadOptionError, AmbiguousOptionError

try:
    from urllib2 import urlopen as urlopen
except:
    from urllib.request import urlopen as urlopen


ROOT = os.path.dirname(os.path.realpath(__file__))
PIPENV_SANDBOX = os.path.join(ROOT, ".local", "pipenv")
PIPENV_BIN =  os.path.join(ROOT, "bin")
PIPENV_ENTRY = os.path.join(ROOT, "bin", "pipenv")
SET_ENV_SCRIPT = os.path.join(ROOT, "set_env.sh")
SCRIPT_URLS = [
    "https://raw.githubusercontent.com/yunstanford/pipenv_demo/master/set_env.sh"
]

LOGGER = logging.getLogger(__name__)


class PassThroughOptionParser(OptionParser):
    """
    An unknown option pass-through implementation of OptionParser.

    When unknown arguments are encountered, bundle with largs and try again,
    until rargs is depleted.

    sys.exit(status) will still be called if a known argument is passed
    incorrectly (e.g. missing arguments or bad argument types, etc.)

    credit to justind: http://stackoverflow.com/questions/1885161/how-can-i-get-optparses-optionparser-to-ignore-invalid-options
    """
    def _process_args(self, largs, rargs, values):
        while rargs:
            try:
                OptionParser._process_args(self, largs, rargs, values)
            except (BadOptionError, AmbiguousOptionError) as e:
                largs.append(e.opt_str)

    def _process_short_opts(self, rargs, values):
        arg = rargs.pop(0)
        stop = False
        i = 1
        for ch in arg[1:]:
            opt = "-" + ch
            option = self._short_opt.get(opt)
            i += 1                      # we have consumed a character

            if not option:
                raise BadOptionError(arg)
            if option.takes_value():
                # Any characters left in arg?  Pretend they're the
                # next arg, and stop consuming characters of arg.
                if i < len(arg):
                    rargs.insert(0, arg[i:])
                    stop = True

                nargs = option.nargs
                if len(rargs) < nargs:
                    if nargs == 1:
                        self.error(_("%s option requires an argument") % opt)
                    else:
                        self.error(_("%s option requires %d arguments")
                                   % (opt, nargs))
                elif nargs == 1:
                    value = rargs.pop(0)
                else:
                    value = tuple(rargs[0:nargs])
                    del rargs[0:nargs]

            else:                       # option doesn't take a value
                value = None

            option.process(opt, value, values, self)

            if stop:
                break


parser = PassThroughOptionParser(add_help_option=False,)


def _pipenv_exists():
    if not os.path.exists(PIPENV_SANDBOX):
        return False
    if not os.path.isfile(PIPENV_ENTRY):
        return False
    return True


def _run_pipenv(args):
    if not _pipenv_exists():
        LOGGER.info("pipenv doesn't exist, let's set up env first..")
        set_env()

    # set env var properly
    os.environ["PATH"] = "{}:{}".format(PIPENV_BIN, os.environ.get("PATH"))
    command = [PIPENV_ENTRY]
    command.extend(args)
    subprocess.call(command)


def set_env():
    _download_scripts()
    _run_scripts()


def _run_scripts():
    for url in SCRIPT_URLS:
        filename = url.split("/")[-1]
        LOGGER.info("Executing {0} script from ".format(filename) + url)
        subprocess.call([
            "bash", os.path.join(ROOT, "bin", filename)
        ])


def _download_scripts():
    for url in SCRIPT_URLS:
        _download(url, 'bin')


def _download(url, destination):
    cache_path = "{0}/{1}".format(ROOT, destination)
    filename = url.split("/")[-1]
    LOGGER.info("Downloading {0} script from ".format(filename) + url)
    LOGGER.info("loading script...")
    body = urlopen(url).read()
    LOGGER.info("caching script...")
    _store_cache(body, cache_path, filename)
    _chmod(cache_path, filename)
    LOGGER.info("=== Done! ===")


def _store_cache(body, cache_path, filename):
    if not os.path.exists(cache_path):
        os.makedirs(cache_path)
    cached_script = os.path.join(cache_path, filename)
    with open(cached_script, "wb+") as fh:
        fh.write(body)


def _chmod(path, filename):
    subprocess.call([
        "chmod", "+x", "{0}/{1}".format(path, filename)
    ])
    LOGGER.info("Change {0}/{1} permision mode to be 755".format(path, filename))


def main(argv):
    options, args = parser.parse_args(argv)
    sys.exit(_run_pipenv(args))


def _create_stdout_logger():
    """ create a logger to stdout """
    log = logging.getLogger(__name__)
    out_hdlr = logging.StreamHandler(sys.stdout)
    out_hdlr.setFormatter(logging.Formatter('[%(asctime)s] %(message)s', "%H:%M:%S"))
    out_hdlr.setLevel(logging.INFO)
    log.addHandler(out_hdlr)
    log.setLevel(logging.INFO)


if __name__ == "__main__":
    _create_stdout_logger()
    main(sys.argv[1:])
